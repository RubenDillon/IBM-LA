Integracion con IBM Concert
=

En este apartado, vamos a estar integrando Instana con IBM Concert, para lo que es Vulnerabilidades.

La integracion con IBM Concert se da en doble sentido, desde la Interfaz de Concert como desde la interfaz de Instana. Finalmente, el agnete de Instana tiene que activar el sensor CVE.

En nuestro caso, aprovechamos el uso de los trials de IBM Instana y de IBM Concert.


Integracion de ambas plataformas
-

**Step 1**: Generate an Instana API token
From the navigation menu in the Instana UI, click Settings > Security & Access > API Tokens.

  - Click New API Token.

  - Enter a unique name for your API token, such as Concert.

  - For the Instana-Concert integration, the default token permissions are sufficient as Concert uses read-only APIs.


After the API token generates, copy it to a secure location. You need it when you create the connection in Concert.


**Step 2**: Establish a connection with Instana
In the Concert UI, establish a connection with Instana by completing the following steps:

  - From the Concert navigation menu, go to Administration > Integrations.

  - On the Connections tab, click Create connection.

  - Select IBM Instana Observability. Use the search bar or scroll to find.

  - On the Create IBM Instana Observability connection screen, enter a name and description for the connection.

  - In the Endpoint field, enter the host URL of the Instana application endpoint in one of the following formats.

  - We will put our tenant  https://myname-instana.instana.io

  - Enter the Instana API token that you generated in step 1.

  - Click Validate connection.

  - After the connection validates, click Create.


**Step 3**: Create a data ingestion job in Concert
To create an ingestion job to pull application and environment data from Instana to Concert, complete the following steps:

  - In the Concert UI, click Administration > Integrations.

  - On the Ingestion jobs tab, click Create ingestion job.

  - Enter a name and description for the ingestion job.

  - For Connection type, select Instana.

  - For Connection, select the name of the connection that you created in the previous step.

  - Select the Target environment that is defined in your Concert inventory.

  - Click Create. The new ingestion job appears in the list.

  - Click the overflow menu for the ingestion job you created and select Run now to start ingesting data from Instana.

**Step 4**: Generate a Concert API key
In the Concert UI, click Profile > API key.

  - Click Generate API key.

  - After the API key generates, copy it to a secure location. You need it when you configure the CVE sensor in Instana.


**Step 5**: Configure the CVE sensor in Instana
The Instana CVE sensor collects vulnerability data from Concert so you can view it in Instana.

  - Enable the CVE sensor by updating the agent configuration file /opt/instana/agent/etc/instana/configuration.yaml, as shown in the following example:

<img width="1037" height="167" alt="image" src="https://github.com/user-attachments/assets/f6a703e2-0617-476d-b09e-9538ef1a6675" />

Our current Environment is like this
  - Instana: https://yellow-tanganyika0z3tc.instana.io/
  - Concert: https://71538.jp-tok-2.concert.saas.ibm.com/#/home?instance_id=20250802-2204-1075-61d7-381f41e7b94c

Creacion de aplicacion en Concert
-

Para la prueba de integracion entre Instana y Concert, vamos a volver a utilizar RobotShop (podriamos usar la aplicacion que quisieramos.. como puede ser Quote of the Day)

Lo primero que debemos hacer, es crear la relacion entre Entornos y Aplicacion. Para ello, creamos un archivo de definicion ConcertDEF.

A continuacion el ejemplo para algunos componentes de RobotShop

```
{
    "bomFormat": "ConcertDef",
    "specVersion": "1.0.2",
    "metadata": {
        "timestamp": "2025-09-03T02:51:18Z",
        "type": "application",
        "component": {
            "name": "robo-shop",
            "version": "1.0.0.0"
        },
        "business": {
            "name": "MyOrg",
            "units": [
                {
                    "name": "Business Unit name",
                    "email": "myemail@myorg.com",
                    "phone": "(123) 123-1234"
                }
            ]
        }
    },
    "environments": [
        {
            "bom-ref": "environment:development",
            "type": "environment",
            "name": "development"
        },
        {
            "bom-ref": "environment:pre-production",
            "type": "environment",
            "name": "pre-production"
        },
        {
            "bom-ref": "environment:production",
            "type": "environment",
            "name": "production"
        }
    ],
    "components": [
        {
            "bom-ref": "build:RobotShop",
            "type": "build",
            "name": "RobotShop",
            "version": "1.0.0",
            "components": [
                {
                    "bom-ref": "737471e070ad326b",
                    "type": "container",
                    "name": "robotshop/rs-web",
                    "version": "2.1.0", 
                    "uri": "robotshop/rs-web:2.1.0t@sha256:b3c20d4a22f2875397726d2184062360bb2ab9c8776beffca7c2e7b3652893bc"
                },
                {
                    "bom-ref": "repository:coderepo:github:myapp-component",
                    "type": "code",
                    "name": "myapp-component",
                    "purl": "https://github.com/myorg/myapp-component",
                    "branch": "",
                    "commit_sha": ""
                },
                {
                    "bom-ref": "782fac70a4d8c3f1",
                    "type": "container",
                    "name": "robotshop/rs-user",
                    "version": "2.1.0", 
                    "uri": "robotshop/rs-user@sha256:ea509182c180d20340a9427d8320f35085effdb4ed77b15275022d17bdd1fcf7"
                },
                {
                    "bom-ref": "repository:coderepo:github:myapp-component",
                    "type": "code",
                    "name": "myapp-component",
                    "purl": "https://github.com/myorg/myapp-component",
                    "branch": "",
                    "commit_sha": ""
                },
                {
                    "bom-ref": "290fdcb58fd47347",
                    "type": "container",
                    "name": "redis",
                    "version": "6.2-alpine", 
                    "uri": "redis@sha256:7fe72c486b910f6b1a9769c937dad5d63648ddee82e056f47417542dd40825bb"
                },
                {
                    "bom-ref": "repository:coderepo:github:myapp-component",
                    "type": "code",
                    "name": "myapp-component",
                    "purl": "https://github.com/myorg/myapp-component",
                    "branch": "",
                    "commit_sha": ""
                },
                {
                    "bom-ref": "f3aa61f686696b4d",
                    "type": "container",
                    "name": "robotshop/rs-ratings",
                    "version": "2.1.0", 
                    "uri": "robotshop/rs-ratings@sha256:4899c686c249464783663342620425dc8c75a5d59ca55c247cf6aec62a5fff1"
                },
                {
                    "bom-ref": "8f0f1be259b4d82e",
                    "type": "container",
                    "name": "robotshop/rs-mysql-db",
                    "version": "2.1.0", 
                    "uri": "robotshop/rs-mysql-db@sha256:2355f9700d771f4326169d7d370ad1824d2d410876036f77342d9663d80f893b"
                },
                {
                    "bom-ref": "8f0f1be259b4d82e",
                    "type": "container",
                    "name": "robotshop/rs-mongodb",
                    "version": "2.1.0", 
                    "uri": "robotshop/rs-mongodb@sha256:119b545823cdce33a1d6cee87fdfed1cef82e680824ad0b49603be4aeb4e821e"
                },
                {
                    "bom-ref": "4fb01507b5d9c059",
                    "type": "container",
                    "name": "robotshop/rs-shipping",
                    "version": "2.1.0", 
                    "uri": "robotshop/rs-shipping@sha256:89753ab489193286402c9486379da63c18a21d697b4fbd41246b68aacabfc6d3"
                },
                {
                    "bom-ref": "repository:coderepo:github:myapp-component",
                    "type": "code",
                    "name": "myapp-component",
                    "purl": "https://github.com/myorg/myapp-component",
                    "branch": "",
                    "commit_sha": ""
                }
            ]
        }
    ],
    "properties": [
        {
            "name": "application_criticality",
            "value": "5"
        }
    ],
    "services": [
        {
            "bom-ref": "appapi:myapp-component-api",
            "name": "myapp-component-api",
            "endpoints": [
                "/myapp-component"
            ],
            "properties": [
                {
                    "name": "network_exposure",
                    "value": "public"
                }
            ]
        }
    ],
    "dependencies": [
        {
            "ref": "container:robotshop/rs-web:2.1.0",
            "dependsOn": [
                "appapi:myapp-component-api"
            ]
        }
    ]
}

```

Mi recomendacion, es tomar este archivo y usarlo en alguna herramienta que esten acostumbrados... como por ejemplo VS.Code.

Algunas aclaraciones, para que las tengan en cuenta para cuando trabajen en este tipo de archivos
- Debemos crear los ambientes que esta aplicacion va a tener (en este caso definimos development, pre-production, production)
- Debemos crear una relacion entre la aplicacion y los contenedores / hosts (para el caso de maquinas virtuales)
  
Para el caso de contenedores debemos tomar determinados valores, para alimentar la configuracion

```
                    "bom-ref": "4fb01507b5d9c059",
                    "type": "container",
                    "name": "robotshop/rs-shipping",
                    "version": "2.1.0", 
                    "uri": "robotshop/rs-shipping@sha256:89753ab489193286402c9486379da63c18a21d697b4fbd41246b68aacabfc6d3"
```

Por ejemplo  
- el valor bom-ref lo van a sacar del archivo que van a generar con syft
- el uri del contenedor lo van a sacar con una linea de comandos de docker (inspect)

```
docker inspect --format='{{index .RepoDigests 0}}' robotshop/rs-shipping:2.1.0
```

esta linea puede arrojar un resultado como el que sigue

docker inspect --format='{{index .RepoDigests 0}}' robotshop/rs-shipping:2.1.0
robotshop/rs-shipping@sha256:89753ab489193286402c9486379da63c18a21d697b4fbd41246b68aacabfc6d3


Instalación de herramienta para definicion de SBOM
-

Para instalar Syft

```
curl -sSfL https://get.anchore.io/syft | sudo sh -s -- -b /usr/local/bin
```

Ejecutar Syft contra una imagen (Contenedor)

```
syft registry.gitlab.com/quote-of-the-day/qotd-web:v5.1.0 -o cyclonedx-json > web.syft.json
```

Ir a Dimension, Luego Software composition y subir con la interfaz grafica (una de las opciones o por un llamado a API)

<img width="1718" height="874" alt="image" src="https://github.com/user-attachments/assets/6ad992f7-11d4-462e-88bf-dbf240828ffe" />

<img width="653" height="660" alt="image" src="https://github.com/user-attachments/assets/7d4fa120-8980-4821-a704-e9c70e5ba15e" />

NOTA: En la version 2.0 de Concert se agrega algunos campos en la interfaz, para que se haga la relacion de este upload con la aplicacion.

<img width="643" height="616" alt="image" src="https://github.com/user-attachments/assets/4ac23a10-ebaf-4fc4-98b2-55bef2453eb5" />


Event Log

<img width="1703" height="858" alt="image" src="https://github.com/user-attachments/assets/c376511d-00d3-48c5-a3ad-bbceec9b8523" />

<img width="1703" height="858" alt="image" src="https://github.com/user-attachments/assets/1ed15571-2d36-4a46-bdd8-f2da7a910c35" />

Automatizar la recoleccion
-

Para automatizar la recoleccion de los contenedores de RobotShop, podemos utilizar el siguiente script

```
syft robotshop/rs-web:2.1.0 -o cyclonedx-json > web.syft.json
syft robotshop/rs-user:2.1.0 -o cyclonedx-json > user.syft.json
syft robotshop/rs-catalogue:2.1.0 -o cyclonedx-json > cat.syft.json
syft robotshop/rs-shipping:2.1.0 -o cyclonedx-json > ship.syft.json
syft robotshop/rs-ratings:2.1.0 -o cyclonedx-json > rating.syft.json
syft robotshop/rs-dispatch:2.1.0 -o cyclonedx-json > disp.syft.json
syft robotshop/rs-payment:2.1.0 -o cyclonedx-json > pay.syft.json
syft robotshop/rs-cart:2.1.0 -o cyclonedx-json > cart.syft.json
syft rabbitmq:3.8-management-alpine -o cyclonedx-json > rabbit.syft.json
syft redis:6.2-alpine -o cyclonedx-json > redis.syft.json
syft robotshop/rs-mongodb:2.1.0 -o cyclonedx-json > mongo.syft.json
syft robotshop/rs-mysql-db:2.1.0 -o cyclonedx-json > mysql.syft.json
syft robotshop/rs-load:2.1.0 -o cyclonedx-json > load.syft.json

```

Si revisamos el archivo ship.syft.com, veremos el bom-ref del que antes haciamos referencia. Lo mismo va a suceder, si buscamos en el grype que vamos a generar. El bom-ref se mantienen para este contenedor.

<img width="621" height="384" alt="image" src="https://github.com/user-attachments/assets/849b65a0-7ca4-48b0-9927-2ebec8f156cd" />


Instalacion de herramientas de busqueda de vulnerabilidades
-

Para instalar Grype como herramienta de busqueda de Vulnerabilidades

```
curl -sS https://webi.sh/grype | sh; source ~/.config/envman/PATH.env

```
Usar la herramienta para analizar en una imagen (contenedor) de quote of the day 

```
grype registry.gitlab.com/quote-of-the-day/qotd-web:v5.1.0 -o cyclonedx-json > web.json
```

Then upload this image to Concert

<img width="1713" height="865" alt="image" src="https://github.com/user-attachments/assets/1174bcd3-fdaf-4640-83c2-ba372eb9df9a" />

<img width="649" height="640" alt="image" src="https://github.com/user-attachments/assets/893bc4cf-4967-43e1-bafb-92a676d3ae6b" />

Then go to Administration, Event Logs...

<img width="1718" height="874" alt="image" src="https://github.com/user-attachments/assets/b5385fb5-c2e8-451c-aad3-c39eb64827ee" />

<img width="1718" height="874" alt="image" src="https://github.com/user-attachments/assets/ce27f8e0-8b3a-4210-ad6a-29cae72fa8ff" />


Automatizar la recoleccion
-

Para automatizar la recoleccion de los contenedores de RobotShop, podemos utilizar el siguiente script

```
grype robotshop/rs-web:2.1.0 -o cyclonedx-json > web.grype.json
grype robotshop/rs-user:2.1.0 -o cyclonedx-json > user.grype.json
grype robotshop/rs-catalogue:2.1.0 -o cyclonedx-json > cat.grype.json
grype robotshop/rs-shipping:2.1.0 -o cyclonedx-json > ship.grype.json
grype robotshop/rs-ratings:2.1.0 -o cyclonedx-json > rating.grype.json
grype robotshop/rs-dispatch:2.1.0 -o cyclonedx-json > disp.grype.json
grype robotshop/rs-payment:2.1.0 -o cyclonedx-json > pay.grype.json
grype robotshop/rs-cart:2.1.0 -o cyclonedx-json > cart.grype.json
grype rabbitmq:3.8-management-alpine -o cyclonedx-json > rabbit.grype.json
grype redis:6.2-alpine -o cyclonedx-json > redis.grype.json
grype robotshop/rs-mongodb:2.1.0 -o cyclonedx-json > mongo.grype.json
grype robotshop/rs-mysql-db:2.1.0 -o cyclonedx-json > mysql.grype.json
grype robotshop/rs-load:2.1.0 -o cyclonedx-json > load.grype.json
```


Subir estas recolecciones
-

Para subir estas recolecciones, vamos a sus respectivas dimensiones y las subimos manualmente (ya que pesan menos de 10Mb). Otras opciones incluyen incluir llamadas a la API en pipelines o a traves del uso de Concert Workflow.

Una vez subidas, podemos ir a revisar los Event Logs...

<img width="1763" height="660" alt="image" src="https://github.com/user-attachments/assets/9d6bb0a8-6509-4a22-98cb-fa6cb2afef20" />

A partir del procesamiento, vamos a poder ir viendo informacion relacionado a lo recolectado..

<img width="1763" height="867" alt="image" src="https://github.com/user-attachments/assets/59e968e7-4e20-4fbe-8dfa-ca658189e00b" />

<img width="1763" height="867" alt="image" src="https://github.com/user-attachments/assets/469a2570-fbb2-4a5c-b84f-9c01cda8d1fe" />

<img width="1763" height="867" alt="image" src="https://github.com/user-attachments/assets/868aa3b4-adef-4807-a8f2-718f14689b34" />

y solo para no extendernos, podemos adentrarnos en la informacion de las Vulnerabilidades

<img width="1763" height="867" alt="image" src="https://github.com/user-attachments/assets/179780fb-a5ae-4278-8e54-e9a53d2a4757" />

<img width="1763" height="867" alt="image" src="https://github.com/user-attachments/assets/590f11da-764f-47cd-89da-0aaf687e6223" />

<img width="1760" height="1197" alt="image" src="https://github.com/user-attachments/assets/dea9485e-a2f3-4225-a1bd-704884b49269" />

<img width="1760" height="1197" alt="image" src="https://github.com/user-attachments/assets/2fac466d-79d5-4e71-aa2b-482a30db971a" />

<img width="1760" height="1197" alt="image" src="https://github.com/user-attachments/assets/9c1d892b-3536-40f5-a7cd-93250df5043d" />




Uso de herramientas para analizar Maquinas virtuales 
=

Para este apartado vamos a tomar la aplicacion creada en el Workshop de APIC. Son 3 maquinas virtuales linux, donde tenemos un frontend (apache donde corre la aplicacion), un middleware (apache donde corre la API) y finalmente el backend (un mariadb).

En este caso, ya estamos usando Concert 2.0 y los pasos que debemos dar son los siguientes:
- Dividir la aplicacion en capas (escogimos frontend, middle, back)
- Asignamos una VM a cada capa
- Creamos la definicion de Aplicacion para cada capa
- Creamos la asociacion de Aplicacion con un archivo de despliegue
- Ejecutamos syft para desarrollar la composicion del software
- Ejecutamos grype para busqueda de vulnerabilidades


 Definicion de Aplicacion para el FrontEnd
 -

Debemos crear el siguiente archivo, donde cambiaran el nombre de la aplicacion si asi lo requieren, como tambien github y algunos otros parametros que crean convenientes.

```
{
    "bomFormat": "ConcertDef",
    "specVersion": "1.0.2",
    "metadata": {
        "timestamp": "2024-11-21T11:42:35Z",
        "type": "application",
        "component": {
            "name": "API-front",
            "version": "10.0.0"
        }
    },
    "environments": [
        {
            "bom-ref": "environment:dev",
            "type": "environment",
            "name": "dev"
        }
    ],
    "components": [
        {
            "bom-ref": "build:API",
            "type": "build",
            "name": "API",
            "version": "1.0.0",
            "components": [
                {
                    "bom-ref": "pkg:github/API/API@10.0.0",
                    "purl": "pkg:github/API/API@10.0.0",
                    "type": "library",
                    "name": "API",
                    "version": "10.0.0"
                },
                {
                    "bom-ref": "repository:coderepo:github:API-repo",
                    "type": "code",
                    "name": "API-repo",
                    "purl": "https://github.com/API/API",
                    "branch": "master"
                }
            ]
        }
    ],
    "properties": [
        {
            "name": "application_criticality",
            "value": "4"
        }
    ],
    "services": [
    ],
    "dependencies": [
        {
            "ref": "pkg:github/API/API@10.0.0",
            "dependsOn": [
                "repository:coderepo:github:API-repo"
            ]
        }
    ]
}
```

Una vez creado el archivo, lo debemos subir a Concert a traves de la UI

<img width="1374" height="937" alt="image" src="https://github.com/user-attachments/assets/189d7a0e-09e2-4ad5-bc07-02c2ebc65896" />


 Archivo de despliegue para el FrontEnd
 -

Debemos crear el siguiente archivo de despliegue, se debe prestar particular atencion en el nombre de la aplicacion, en el github, en el repo que crean ya que es la forma de enlazar el despliegue con la aplicacion, para que a su vez el syft y el grype esten relacionados.

```
{
    "bomFormat": "ConcertDef",
    "specVersion": "1.0.2",
    "metadata": {
        "timestamp": "2025-09-12T19:29:00-03:00",
        "type": "deploy",
        "environment": "dev",
        "component": {
            "name": "API-front",
            "version": "10.0.0",
            "deploy-number": "31"
        }
    },
    "components": [
        {
            "bom-ref": "repository:coderepo:github:API-repo",
            "type": "code",
            "name": "API-repo",
            "purl": "https://github.com/API/API",
            "branch": "master"
        }
    ],
    "runtime-components": [
        {
            "bom-ref": "service:vm:ancap-linux1",
            "name": "linux1",
            "type": "vm",
            "ipv4": [
                {
                    "addr": "10.241.64.82"
                }
            ],
            "ipv6": [
                {
                    "addr": "fe80::5:74ff:fe7a:4987"
                }
            ],
            "hostname": "itzvsi-696000dpm9-lno7hv90",
            "properties": [
                {
                    "name": "os",
                    "value": "rhel"
                },
                {
                    "name": "version",
                    "value": "9.3"
                },
                {
                    "name": "product_label",
                    "value": "enterprise"
                }
            ],
            "components": [
                {
                    "bom-ref": "pkg:github/API/API@10.0.0",
                    "purl": "pkg:github/API/API@10.0.0",
                    "type": "library",
                    "name": "API",
                    "version": "10.0.0"
                }
            ]
        }
    ],
    "services": [
    ]
}
```

Una vez creado el archivo, lo debemos subir a Concert a traves de la UI

<img width="1374" height="937" alt="image" src="https://github.com/user-attachments/assets/5d6b96f3-5f4e-48aa-94fd-bf376f71d976" />


 Syft para el FrontEnd
 -

Para el syft debemos crear un script (para simplificar) y lo ejecutamos desde la VM. En este caso, deben prestar atencion en los parametros que se le dan al llamado de la API de Concert. Los valores de la API se obtienen desde la interfaz de Concert.

Para crear los valores de la API, vamos a la interfaz de Concert y usamos el icono que esta al lado del usuario (arriba a la derecha con forma de llave)

<img width="820" height="511" alt="image" src="https://github.com/user-attachments/assets/0e9efbbb-c25c-48b1-bda5-b334f0a4d1da" />

Continuar con los datos ahi ofrecidos, para al Aceptar obtener la siguiente pantalla
<img width="976" height="422" alt="image" src="https://github.com/user-attachments/assets/5a2839e4-80b9-4f17-830a-8315b98ed6ce" />

A continuacion, el script donde instalamos syft y grype en la maquina. Luego hacemos la ejecucion de syft y una vez finalizado, subimos a la API de Concert con los parametros correctos. En mi caso, estos son los parametros de
- el tenant actual de Concert (un trial de 30 dias)
- el API Key obtenido del paso previo
- la instancia del tenant de Concert

```
curl -sS https://webi.sh/grype | sh; source ~/.config/envman/PATH.env

curl -sSfL https://get.anchore.io/syft | sudo sh -s -- -b /usr/local/bin

/usr/local/bin/syft dir:/ -o cyclonedx-json > front.syft.json


curl -k --request POST --url "https://93252.us-south-8.concert.saas.ibm.com/concert/ingestion/api/v1/upload_files" \
    --header 'Authorization: C_API_KEY cnViZW4uZGlsbG9uQGlibS5jb206NDllZWNhY2UtYzYwYS00YWJlLThiMDEtMGZlMTU1YTA2MjU5' \
    --header 'InstanceId: 20250902-2259-0285-91c9-4161d68281fc' \
    --header 'Content-Type: multipart/form-data' \
    --form data_type=package_sbom \
    --form filename=@front.syft.json  \
    --form 'metadata={"repo_url": "https://github.com/API/API","application_name":"API-front","application_version" : "10.0.0","component_name":"API-repo","component_type":"repository"}'
```

Una vez ejecutado, obtendremos una serie de mensajes pero el que nos interesa es el "202 Accepted" {"message":"202 Accepted"} como respuesta de la API.

 Grype para el FrontEnd
 -

Similar a Syft, hay que crear el script y ejecutarlo desde la VM. Hay que prestar atencion, con los parametros de la API. 

```
grype dir:/ -o cyclonedx-json > front.grype.json

curl -k --request POST --url "https://93252.us-south-8.concert.saas.ibm.com/concert/ingestion/api/v1/upload_files" \
    --header 'Authorization: C_API_KEY cnViZW4uZGlsbG9uQGlibS5jb206NDllZWNhY2UtYzYwYS00YWJlLThiMDEtMGZlMTU1YTA2MjU5' \
    --header 'InstanceId: 20250902-2259-0285-91c9-4161d68281fc' \
    --header 'Content-Type: multipart/form-data' \
    --form data_type=code_scan \
    --form filename=@front.grype.json \
    --form 'metadata={"repo_url":"https://github.com/API/API", "application_name":"API-front", "application_version":"10.0.0"}' 
```


Una vez ejecutado, obtendremos una serie de mensajes pero el que nos interesa es el "202 Accepted" {"message":"202 Accepted"} como respuesta de la API.

En la Interfaz de Concert podemos ver creada la capa Front End, sus paquetes y sus Vulnerabilidades.

<img width="1685" height="1027" alt="image" src="https://github.com/user-attachments/assets/bb9d6002-a777-4582-8d62-50e93149e412" />

<img width="1685" height="1027" alt="image" src="https://github.com/user-attachments/assets/5c91d82f-9c12-4b14-a8c8-0e4c47d2410d" />

<img width="1685" height="1027" alt="image" src="https://github.com/user-attachments/assets/93991537-370b-46af-bc90-66a6dd9a392a" />



 Definicion de Aplicacion para el middle tier
 -

Debemos crear el siguiente archivo, donde cambiaran el nombre de la aplicacion si asi lo requieren, como tambien github y algunos otros parametros que crean convenientes.

```
{
    "bomFormat": "ConcertDef",
    "specVersion": "1.0.2",
    "metadata": {
        "timestamp": "2024-11-21T11:42:35Z",
        "type": "application",
        "component": {
            "name": "API-middle",
            "version": "10.0.0"
        }
    },
    "environments": [
        {
            "bom-ref": "environment:dev",
            "type": "environment",
            "name": "dev"
        }
    ],
    "components": [
        {
            "bom-ref": "build:API-middle",
            "type": "build",
            "name": "API-middle",
            "version": "1.0.0",
            "components": [
                {
                    "bom-ref": "pkg:github/API/API-middle@10.0.0",
                    "purl": "pkg:github/API/API-middle@10.0.0",
                    "type": "library",
                    "name": "API-middle",
                    "version": "10.0.0"
                },
                {
                    "bom-ref": "repository:coderepo:github:API-middle-repo",
                    "type": "code",
                    "name": "API-middle-repo",
                    "purl": "https://github.com/API/API-middle",
                    "branch": "master"
                }
            ]
        }
    ],
    "properties": [
        {
            "name": "application_criticality",
            "value": "4"
        }
    ],
    "services": [
    ],
    "dependencies": [
        {
            "ref": "pkg:github/API/API@10.0.0",
            "dependsOn": [
                "repository:coderepo:github:API-middle-repo"
            ]
        }
    ]
}
```

Una vez creado el archivo, lo debemos subir a Concert a traves de la UI como lo hemos hecho con front.


 Archivo de despliegue para el middle
 -

Debemos crear el siguiente archivo de despliegue, se debe prestar particular atencion en el nombre de la aplicacion, en el github, en el repo que crean ya que es la forma de enlazar el despliegue con la aplicacion, para que a su vez el syft y el grype esten relacionados.

```
{
    "bomFormat": "ConcertDef",
    "specVersion": "1.0.2",
    "metadata": {
        "timestamp": "2025-09-12T19:29:00-03:00",
        "type": "deploy",
        "environment": "dev",
        "component": {
            "name": "API-middle",
            "version": "10.0.0",
            "deploy-number": "32"
        }
    },
    "components": [
        {
            "bom-ref": "repository:coderepo:github:API-middle-repo",
            "type": "code",
            "name": "API-middle-repo",
            "purl": "https://github.com/API/API-middle",
            "branch": "master"
        }
    ],
    "runtime-components": [
        {
            "bom-ref": "service:vm:ancap-linux2",
            "name": "linux2",
            "type": "vm",
            "ipv4": [
                {
                    "addr": "10.241.64.83"
                }
            ],
            "ipv6": [
                {
                    "addr": "fe80::5:74ff:fe7a:4999"
                }
            ],
            "hostname": "itzvsi-696000dpm9-ffkcqklr",
            "properties": [
                {
                    "name": "os",
                    "value": "rhel"
                },
                {
                    "name": "version",
                    "value": "9.3"
                },
                {
                    "name": "product_label",
                    "value": "enterprise"
                }
            ],
            "components": [
                {
                    "bom-ref": "pkg:github/API/API-middle@10.0.0",
                    "purl": "pkg:github/API/API-middle@10.0.0",
                    "type": "library",
                    "name": "API-middle",
                    "version": "10.0.0"
                }
            ]
        }
    ],
    "services": [
    ]
}

```

Una vez creado el archivo, lo debemos subir a Concert a traves de la UI como lo hemos hecho con front.



 Syft para el middle
 -

Para el syft creamos el siguiente script y lo ejecutamos desde la VM. En este caso, deben prestar atencion en los parametros que se le dan al llamado de la API de Concert. 

```
curl -sS https://webi.sh/grype | sh; source ~/.config/envman/PATH.env

curl -sSfL https://get.anchore.io/syft | sudo sh -s -- -b /usr/local/bin

/usr/local/bin/syft dir:/ -o cyclonedx-json > middle.syft.json

curl -k --request POST --url "https://93252.us-south-8.concert.saas.ibm.com/concert/ingestion/api/v1/upload_files" \
    --header 'Authorization: C_API_KEY cnViZW4uZGlsbG9uQGlibS5jb206NDllZWNhY2UtYzYwYS00YWJlLThiMDEtMGZlMTU1YTA2MjU5' \
    --header 'InstanceId: 20250902-2259-0285-91c9-4161d68281fc' \
    --header 'Content-Type: multipart/form-data' \
    --form data_type=package_sbom \
    --form filename=@middle.syft.json  \
    --form 'metadata={"repo_url": "https://github.com/API/API-middle","application_name":"API-middle","application_version" : "10.0.0","component_name":"API-middle-repo","component_type":"repository"}'

```

Una vez ejecutado, obtendremos una serie de mensajes pero el que nos interesa es el "202 Accepted" {"message":"202 Accepted"} como respuesta de la API.

 Grype para el middle
 -

Similar a Syft, hay que crear el script y ejecutarlo desde la VM. Hay que prestar atencion, con los parametros de la API. 

```
grype dir:/ -o cyclonedx-json > middle.grype.json

curl -k --request POST --url "https://93252.us-south-8.concert.saas.ibm.com/concert/ingestion/api/v1/upload_files" \
    --header 'Authorization: C_API_KEY cnViZW4uZGlsbG9uQGlibS5jb206NDllZWNhY2UtYzYwYS00YWJlLThiMDEtMGZlMTU1YTA2MjU5' \
    --header 'InstanceId: 20250902-2259-0285-91c9-4161d68281fc' \
    --header 'Content-Type: multipart/form-data' \
    --form data_type=code_scan \
    --form filename=@middle.grype.json \
    --form 'metadata={"repo_url":"https://github.com/API/API-middle", "application_name":"API-middle", "application_version":"10.0.0"}' 

```


Una vez ejecutado, obtendremos una serie de mensajes pero el que nos interesa es el "202 Accepted" {"message":"202 Accepted"} como respuesta de la API.


 Definicion de Aplicacion para el Backend.
 -

Debemos crear el siguiente archivo, donde cambiaran el nombre de la aplicacion si asi lo requieren, como tambien github y algunos otros parametros que crean convenientes.

```

{
    "bomFormat": "ConcertDef",
    "specVersion": "1.0.2",
    "metadata": {
        "timestamp": "2024-11-21T11:42:35Z",
        "type": "application",
        "component": {
            "name": "API-back",
            "version": "10.0.0"
        }
    },
    "environments": [
        {
            "bom-ref": "environment:dev",
            "type": "environment",
            "name": "dev"
        }
    ],
    "components": [
        {
            "bom-ref": "build:API-back",
            "type": "build",
            "name": "API-back",
            "version": "1.0.0",
            "components": [
                {
                    "bom-ref": "pkg:github/API/API-back@10.0.0",
                    "purl": "pkg:github/API/API-back@10.0.0",
                    "type": "library",
                    "name": "API-back",
                    "version": "10.0.0"
                },
                {
                    "bom-ref": "repository:coderepo:github:API-back-repo",
                    "type": "code",
                    "name": "API-back-repo",
                    "purl": "https://github.com/API/API-back",
                    "branch": "master"
                }
            ]
        }
    ],
    "properties": [
        {
            "name": "application_criticality",
            "value": "4"
        }
    ],
    "services": [
    ],
    "dependencies": [
        {
            "ref": "pkg:github/API/API@10.0.0",
            "dependsOn": [
                "repository:coderepo:github:API-back-repo"
            ]
        }
    ]
}
```

Una vez creado el archivo, lo debemos subir a Concert a traves de la UI



 Archivo de despliegue para el backend
 -

Debemos crear el siguiente archivo de despliegue, se debe prestar particular atencion en el nombre de la aplicacion, en el github, en el repo que crean ya que es la forma de enlazar el despliegue con la aplicacion, para que a su vez el syft y el grype esten relacionados.

```
{
    "bomFormat": "ConcertDef",
    "specVersion": "1.0.2",
    "metadata": {
        "timestamp": "2025-09-12T19:29:00-03:00",
        "type": "deploy",
        "environment": "dev",
        "component": {
            "name": "API-back",
            "version": "10.0.0",
            "deploy-number": "33"
        }
    },
    "components": [
        {
            "bom-ref": "repository:coderepo:github:API-back-repo",
            "type": "code",
            "name": "API-back-repo",
            "purl": "https://github.com/API/API-back",
            "branch": "master"
        }
    ],
    "runtime-components": [
        {
            "bom-ref": "service:vm:ancap-linux3",
            "name": "linux3",
            "type": "vm",
            "ipv4": [
                {
                    "addr": "10.241.64.84"
                }
            ],
            "ipv6": [
                {
                    "addr": "fe80::5:74ff:fe7a:4902"
                }
            ],
            "hostname": "itzvsi-696000dpm9-87fj7sbm",
            "properties": [
                {
                    "name": "os",
                    "value": "rhel"
                },
                {
                    "name": "version",
                    "value": "9.3"
                },
                {
                    "name": "product_label",
                    "value": "enterprise"
                }
            ],
            "components": [
                {
                    "bom-ref": "pkg:github/API/API-back@10.0.0",
                    "purl": "pkg:github/API/API-back@10.0.0",
                    "type": "library",
                    "name": "API-back",
                    "version": "10.0.0"
                }
            ]
        }
    ],
    "services": [
    ]
}

```

Una vez creado el archivo, lo debemos subir a Concert a traves de la UI



 Syft para el backend
 -

Para el syft creamos el siguiente script y lo ejecutamos desde la VM. En este caso, deben prestar atencion en los parametros que se le dan al llamado de la API de Concert. 

```
curl -sS https://webi.sh/grype | sh; source ~/.config/envman/PATH.env

curl -sSfL https://get.anchore.io/syft | sudo sh -s -- -b /usr/local/bin

/usr/local/bin/syft dir:/ -o cyclonedx-json > back.syft.json

curl -k --request POST --url "https://93252.us-south-8.concert.saas.ibm.com/concert/ingestion/api/v1/upload_files" \
    --header 'Authorization: C_API_KEY cnViZW4uZGlsbG9uQGlibS5jb206NDllZWNhY2UtYzYwYS00YWJlLThiMDEtMGZlMTU1YTA2MjU5' \
    --header 'InstanceId: 20250902-2259-0285-91c9-4161d68281fc' \
    --header 'Content-Type: multipart/form-data' \
    --form data_type=package_sbom \
    --form filename=@back.syft.json  \
    --form 'metadata={"repo_url": "https://github.com/API/API-back","application_name":"API-back","application_version" : "10.0.0","component_name":"API-back-repo","component_type":"repository"}'

```

Una vez ejecutado, obtendremos una serie de mensajes pero el que nos interesa es el "202 Accepted" {"message":"202 Accepted"} como respuesta de la API.

 Grype para el backend
 -

Similar a Syft, hay que crear el script y ejecutarlo desde la VM. Hay que prestar atencion, con los parametros de la API. 

```
grype dir:/ -o cyclonedx-json > back.grype.json

curl -k --request POST --url "https://93252.us-south-8.concert.saas.ibm.com/concert/ingestion/api/v1/upload_files" \
    --header 'Authorization: C_API_KEY cnViZW4uZGlsbG9uQGlibS5jb206NDllZWNhY2UtYzYwYS00YWJlLThiMDEtMGZlMTU1YTA2MjU5' \
    --header 'InstanceId: 20250902-2259-0285-91c9-4161d68281fc' \
    --header 'Content-Type: multipart/form-data' \
    --form data_type=code_scan \
    --form filename=@back.grype.json \
    --form 'metadata={"repo_url":"https://github.com/API/API-back", "application_name":"API-back", "application_version":"10.0.0"}' 
```


Una vez ejecutado, obtendremos una serie de mensajes pero el que nos interesa es el "202 Accepted" {"message":"202 Accepted"} como respuesta de la API.

Resultados finales teniendo Robot-Shop en docker y la aplicacion API en Maquinas virtuales
=

A continuacion una serie de representaciones de lo que Concert en su version 2.0 al 26 de Septiembre de 2025 muestra con esta informacion.

<img width="1761" height="1027" alt="image" src="https://github.com/user-attachments/assets/9b87aa98-1c85-444b-95c5-377e9f59710d" />

<img width="1761" height="1027" alt="image" src="https://github.com/user-attachments/assets/1e1425c1-9f66-4873-b4a8-111598c05028" />

<img width="1761" height="1027" alt="image" src="https://github.com/user-attachments/assets/c2d3c9fe-4b23-4cbf-a2ca-8a0f255ce3dd" />

<img width="1761" height="1027" alt="image" src="https://github.com/user-attachments/assets/a73d9be2-675c-4b94-8b2c-558f6c0ca335" />

<img width="1761" height="1027" alt="image" src="https://github.com/user-attachments/assets/9266fd0a-afd6-4f40-a9a7-d518083af6d4" />

<img width="1761" height="1027" alt="image" src="https://github.com/user-attachments/assets/d93f78dd-da56-4090-a961-a3a597ee6608" />

<img width="1761" height="1027" alt="image" src="https://github.com/user-attachments/assets/b2d8c782-7f3d-4c4d-b135-a26d943be26c" />

<img width="1761" height="1027" alt="image" src="https://github.com/user-attachments/assets/02ebf3a2-225f-4d2e-bbbb-1577558ed309" />

<img width="1761" height="1027" alt="image" src="https://github.com/user-attachments/assets/e9d8ded1-65a9-42e9-99a4-d46a89c54da3" />

<img width="1761" height="1027" alt="image" src="https://github.com/user-attachments/assets/5038ca28-429f-4d62-8ae0-bc543c77e2b9" />

<img width="1761" height="1027" alt="image" src="https://github.com/user-attachments/assets/17b520ee-a238-4d5c-a3f4-a16f03924d1f" />



Documentacion utilizada
-

- https://www.ibm.com/docs/en/concert?topic=dimension-supported-vulnerability-scan-formats
- https://trivy.dev/latest/docs/configuration/reporting/
- https://webinstall.dev/grype/
- 

Example for automate the syft and grype recolection for images from Docker Hub
-

```
syft robotshop/rs-web:2.1.0 -o cyclonedx-json > web.syft.json
syft robotshop/rs-user:2.1.0 -o cyclonedx-json > user.syft.json
syft robotshop/rs-catalogue:2.1.0 -o cyclonedx-json > cat.syft.json
syft robotshop/rs-shipping:2.1.0 -o cyclonedx-json > ship.syft.json
syft robotshop/rs-ratings:2.1.0 -o cyclonedx-json > rating.syft.json
syft robotshop/rs-dispatch:2.1.0 -o cyclonedx-json > disp.syft.json
syft robotshop/rs-payment:2.1.0 -o cyclonedx-json > pay.syft.json
syft robotshop/rs-cart:2.1.0 -o cyclonedx-json > cart.syft.json
syft rabbitmq:3.8-management-alpine -o cyclonedx-json > rabbit.syft.json
syft redis:6.2-alpine -o cyclonedx-json > redis.syft.json
syft robotshop/rs-mongodb:2.1.0 -o cyclonedx-json > mongo.syft.json
syft robotshop/rs-mysql-db:2.1.0 -o cyclonedx-json > mysql.syft.json
syft robotshop/rs-load:2.1.0 -o cyclonedx-json > load.syft.json
```

```
grype robotshop/rs-web:2.1.0 -o cyclonedx-json > web.grype.json
grype robotshop/rs-user:2.1.0 -o cyclonedx-json > user.grype.json
grype robotshop/rs-catalogue:2.1.0 -o cyclonedx-json > cat.grype.json
grype robotshop/rs-shipping:2.1.0 -o cyclonedx-json > ship.grype.json
grype robotshop/rs-ratings:2.1.0 -o cyclonedx-json > rating.grype.json
grype robotshop/rs-dispatch:2.1.0 -o cyclonedx-json > disp.grype.json
grype robotshop/rs-payment:2.1.0 -o cyclonedx-json > pay.grype.json
grype robotshop/rs-cart:2.1.0 -o cyclonedx-json > cart.grype.json
grype rabbitmq:3.8-management-alpine -o cyclonedx-json > rabbit.grype.json
grype redis:6.2-alpine -o cyclonedx-json > redis.grype.json
grype robotshop/rs-mongodb:2.1.0 -o cyclonedx-json > mongo.grype.json
grype robotshop/rs-mysql-db:2.1.0 -o cyclonedx-json > mysql.grype.json
grype robotshop/rs-load:2.1.0 -o cyclonedx-json > load.grype.json
```

Example for automate syft to recolect information about the host and the docker containers running
-

```
#!/bin/bash

# Directorio donde se guardarán los SBOMs
OUTPUT_DIR="./sbom-report"
mkdir -p "$OUTPUT_DIR/containers"
mkdir -p "$OUTPUT_DIR/host"

# 1. Analizar todos los contenedores en ejecución
echo "[*] Analizando contenedores en ejecución..."
containers=$(docker ps -q)

if [ -z "$containers" ]; then
  echo "[-] No hay contenedores en ejecución."
else
  for cid in $containers; do
    name=$(docker inspect --format='{{.Name}}' "$cid" | sed 's/^\///') # sin la primera "/"
    echo "  [+] Generando SBOM para contenedor: $name ($cid)"
    syft "docker:$cid" -o json > "$OUTPUT_DIR/containers/sbom-${name}.json"
  done
fi

# 2. Analizar el sistema host (excluyendo /proc, /sys, /dev)
echo "[*] Analizando el host..."
sudo syft dir:/ --exclude /proc --exclude /sys --exclude /dev --exclude /run -o json > "$OUTPUT_DIR/host/sbom-host.json"

echo "[✔] Análisis completo. Resultados en: $OUTPUT_DIR/"
```
